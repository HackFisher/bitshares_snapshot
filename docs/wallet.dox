/**
@defgroup wallet_specification BitShares Wallet High-Level Specification
@brief Desired functionality and algorithms used for bitshares wallet

# Wallet Functionality

## JSON RPC API Overview
All commands are issued to the wallet via its JSON-RPC interface. For example, the wallet's command-line interface parses commands entered by the user and generates RPC calls to the underlying wallet backend. The API for the wallet's JSON RPC interface is described in a separate section near the end of this document. The JSON-RPC standard itself is described here: http://json-rpc.org/. Web-based interfaces to the wallet will directly communicate with the wallet engine via this RPC interface.

## Passwords
A wallet potentially has two passwords: a "wallet password" that unencypts the wallet for basic reporting of wallet status (balances, transactions, etc) and a "spending password" that unencrypts the private keys so that the user can issue transactions to spend currency in the wallet.

A wallet password is not required by the wallet. If the wallet password is left blank, the wallet file (which contains a cache of the wallet status such as wallet-affecting transactions, etc) will be stored in human-readable JSON form. If a wallet password is required by the wallet, no commands can be performed on the wallet until the wallet password is provided.

A spending password is required by the wallet, and it must be at least 8 characters in length. If the user attempts an operation that requires access to the private keys when the keys are not in memory (keys are not held in memory by default), the wallet will automatically generate a request for the spending password. Once the spending password is entered, the wallet will unencrypt the private keys and keep them in memory until a timeout occurs (by default we will use a 5 minute timeout if the user doesn't specify one).


## TODO: Wallet accounts and address memos
The bitshares wallet supports accounts similar to the accounts supported by the bitcoin wallet. Multiple addresses can be attached to a specific account (an account must contain at least one address). Accounts can be used to control what addresses are used as a set of inputs for a transaction and to manage several different balances within a wallet (for example, the same way accounts are used in an accounting package). An address can only be owned by a single account. If an account is not specified when creating or importing the address, the address will be owned by the default account called "". An address's account can be changed by using the setaccount method.

The bitshares wallet also supports the concept of "address memos". An address memo is a comment attached to a specific address. Address memos are primarily useful as a means of documenting the sources of funds in an account.

When you create a new "receive address" with the "getnewaddress" command, you can optionally specify an account (which may or may not exist yet) and a memo. Similarly, when importing a private key, you can specify an account and a memo if you wish.



## Create a transaction cache for transactions that affect user's wallet (e.g. wallet balance)
This cache is built by scanning the blockchain and processing pending transactions (currently only processes blockchain transactions, pending transactions support needs to be added). We'll keep blockchain transactions and pending transactions in separate containers as they need to be managed somewhat differently.

## Compute Confirmed Balance
A transaction is fully confirmed when it's been included into a block that 51% of the delegates have confirmed by issuing follow-on blocks that point back to that block (via the block hash id pointers). Currently this is computed on the fly from the transaction cache. Note: currently code considers all transactions in a block to be confirmed.

## Compute Unconfirmed Balance
Transactions that are not yet fully confirmed are kept in a separate wallet balance (one for each asset type) until they have been fully confirmed. Currently this is computed on the fly from the transaction cache (well, not actually computed at all yet, this needs to be implemented).

## Create transactions from user accounts
- Pick an appropriate set of unspent outputs to act as inputs to the transaction (see pseudocode for description of current algorithm for selecting this set).
- Transfer any overage to a “change” account. Create a new change account for each transaction and ouptut the overage to this account. This implies the user may end up holding a substantial and ever-growing number of keys (see Change addresses discussion).
- Compute any fees required for the transaction and add additional unspent outputs as inputs if required (which changes the fee required again and can in turn require additional inputs...). The minimum fee for a valid transaction is the next_fee (computed by blockchain code, see blockchain.dox for details) * transaction_size_in_bytes. See "Transaction Fee Issues" for potential problems with this approach to fee calculation for the transaction.
- If no change required (an unlikely scenario), remove the change output. Probably we should remove the key we created as well in this case.
- Randomize the ordering of the outputs //TODO
- Report if insufficient funds to perform the transaction
- Submit transaction to the p2p network

## Change addresses
We create one change address (key pair) for every transaction (regardless of whether it's used or not in the transaction). This may work acceptably for human-operated wallets, but it's not a sound strategy for anything that generates transactions in an automated fashion since too many keys will end up being created and stored. This implies we'll want to supply an rpc call that supports generating multi-output transactions so that the rpc client application can generate it's own change addresses (and therefore re-use existing change addresses instead of having to create a new one for each transaction).

We could also potentially prune change address keys when they are "spent", as there should be no reasonable expectation of these being outputs in future transactions (only "receiving addresses" explicitly generated by the user should be expected to receive future payments).

## Transaction Fee Issues

It's possible that a wallet may compute a transaction without having seen the "latest" block (or even several blocks), in which case it's possible the fee_rate could have increased, which could lead to the wallet generating a transaction that won't be accepted by peers (if they've seen the block) or not put into the blockchain. With the current fee algorithm, the fee rate can only increase by 2% per block generated, so we can workaround this issue by paying 110% of the fee (this would allow us to miss 5 blocks all with maximum increases in the fee_rate and still generate a transaction with an acceptable fee for the network).

## Processing transactions in a block
- Check each transaction in a block to see if it affects the user's wallet.

## Process user-created pending transactions
- Process each transaction as locally confirmed (shows in confirmed balance, but transaction itself shows as unconfirmed).

## Process peer-received pending transactions
- Process each transaction as  unconfirmed (shows in unconfirmed balance and transaction shown as unconfirmed).

## Steps in processing a basic currency transaction
- If any of the inputs to the transaction are from accounts we control, decrease the wallet balance by the amount in those accounts (accounts are fully spent by a transaction and any overage is sent to a “change” account as an output of the transaction)
- If any of the outputs to the transaction are to accounts we control, increase the wallet balance by the amounts transferred to those accounts)

Vote down delegates when there is a valid transaction not getting included in the blockchain for more than one block from the time you receive it. For now we will just log this as a diagnostic aid.

## Methods of canceling locally-created transactions
If a transaction has been generated locally but not yet submitted to the p2p network, it can simply be removed from the pending transaction queue.

If a transaction has already been submitted to the network but not yet accepted into a block, it can potentially be canceled by issuing a transaction with a higher fee that double spends one of the inputs of the transaction to be canceled. If this canceling transaction manages to make it to the block generating delegate before the block is created, it will get ranked higher in the transaction list and therefore invalidate the original transaction we want to cancel.

## Processing an invalidated transaction
- Transaction can be invalid due to double-spend of an input
- Transaction can be invalid because its inputs and outputs doen't add up to 0
- TODO: Check code for more ways a received transaction can be rejected as invalid

## Miscellaneous information to report
- List configurable number of recent transactions
- List of pending transactions
- List of named receiving addresses (for incoming transfers)
- List of named addresses to send to (address book for outgoing transfers)
- Add number of confirmations and “delegate voted for” to transaction display
- Report the total number of transactions (confirmed and unconfirmed) that affect the user's wallet (size of transaction cache).

## Importable/Exportable information
- import/export private keys in same format as bitcoin (bitcoin wallet import format).Export wallet in json (this is the default format for the wallet, but the client may need to unencrypt the wallet back to JSON if a wallet passphrase was specified by the user).

## Other features
- Sign a message
- Verify a message
- Set/Verify Wallet Passphrase (none by default)
- Set/Verify Spending Passphrase

## Transaction output claim types
- claim_by_signature_output: claim by owning a bitshares private key that matches public key referenced in the output
- claim_by_pts_output: claim by owning a PTS private key that matches public key referenced in the output (these are only used for initial genesis block allocations)
- claim_name_output: find the registered delegate public key that matches public key referenced in the output.

## Transaction Fee
The transaction fee rate is calculated in the blockchain code and stored into the previous block as "next fee". Fee is validated by all full clients, so the generating delegate can't place an arbitrarily high fee to lock up the network. This means the fee doesn't
actually have to be included in the blockchain, but it's included for now for potential use of some sort by a lightweight client or if old blocks have been discarded from the blockchain.

## Possible ways to annotate a transaction received by the wallet
- Check addresses receiving or sending the money against our "send_to" and "receiving_addresses".
- For receiving addresses, can also show the memo tied to account that contains the address.

## Possible ways to annotate a transaction generated in the wallet
Everything in the above section ("received by the wallet") can be used to document the transaction, plus a user can add a memo to indicate the purpose of the specific transaction when he generates it. There's also some interesting documentation possibilities here for when we generate a series of transactions using the contact authorization system of shared public key generation.

To summarize, we can annotate the following information to a transaction:
transaction memo (only for transactions generated in this wallet), sending account memo, sending address memo, and receiving address memo.


## Wallet GUI additional features
- Display table of all transactions sortable by different column fields


# Detailed BitShares Wallet pseudocode

Major functions:
1) collecting inputs for generating transactions from a specific account or set of accounts
2) generating confirmed and unconfirmed balances for the accounts (there's actually multiples assets for each account)
3) maintaining lists of transactions and pending transactions
4) unwinding pending transactions and blockchain transactions that are rejected. We need to remove these from the unspent outputs of the addresses so that we will no longer count them as unconfirmed balances.

Two types of data in unconfirmed transactions: money in (can't trust for collecting transaction inputs) and money out (should trust for collecting transaction inputs as outputs that have already been spent).

transaction_state: contains effects of a single transaction on the wallet(trx field is the "input" with the broadcast transaction data). We make a transaction_state for each transaction that impacts the various wallet balances (and potentially other states of the wallet if the blockchain supports other types of transactions, although these should possibly be stored in a separate container if needed if they don't affect wallet balance computation also).

new data members for wallet:

_block_transactions: map of transactions in blockchain that affect wallet. These get added by scanning blockchain (whenever we receive a new block) and are never removed (except if block is rejected later). This map just grows larger with time,so it should be handled by database eventually. These transactions may or may not yet be confirmed transactions, depending on how many blocks we have received since the block that included them.


_pending_transactions: transactions not yet in a block. These get added whenever we generate or receive a transaction. They get removed whenever we find them in a block we are scanning (at that point we're moving them to _block_transactions database).
These can't possibly be confirmed transactions, no need to check.
These transactions are primarily used for computing unconfirmed balances, they're not used for either confirmed balances or collecting inputs to fund transactions.  But we still need to accumulate these outputs as they affect the unconfirmed balance of each address. We will need to add them to unspent_balances. We're using a map for the unspent outputs, so we shouldn't need to worry about duplicates when they get added again later when the pending transaction is finally included into a block.

Also these transactions spend our unspent_outputs, so we do need to remove spent outputs from unspent_outputs if they are there: this may or may not have already been done, depending on whether this is a locally generated transaction that we later receive. If we generate it locally, we should account for it when we generate it. If it was a remotely generated transaction from another of our wallets, this is first time this wallet learns about the transaction and it needs to remove it from unspent_outputs. Possibly we could check some map to see if the pending transaction has already been processed, but it shouldn't be a common case (most pending transactions we receive will be from others, not ourselves), so maybe not necessary, needs further thought/investigation. Wallet needs to add new function that can be called by client code when a transaction is received (we'll call this same function when we locally generate a transaction).

Every time we receive a block, initially all it's transactions will be unconfirmed. But the reception of this block will also confirm a block we've previously received. So if we were accumulating balances, we would use the newly received block to modify our unconfirmed balances and use the confirmed block to modify all our confirmed balances (and revert all associated unconfirmed balances). But for now, we'll compute all the balances on request (see compute_balances function), so we don't need to worry about this additional complexity.

struct account
  set<address_state> addresses //we uniquify address_state based on address public key
  balance?
  unconfirmed_balance?
// Add an address to addresses member whenever we create a new address or move it to a different account. Should we have an option to delete an account? I suppose an account is implicitly deleted when all addresses are removed from it. Also, all addresses should belong to some account (there is a default account ("") that should be used when an address is created without specifying an account).

We need to track the unspent_outputs of an account to quickly collect inputs for transactions drawn from that account. The simplest way to do this is to draw from a conceptual union of the unspent_outputs of each address in the account (this simplifies switching addresses between accounts or even deleting an address from consideration entirely if desired).

map<address,outputs> _unspent_outputs_of_address;
//Defines mapping from address to it's unspent outputs.
Add output to outputs subcontainer whenever we scan a transaction that outputs to the address(scan_output). What about outputs from pending transactions? Let's not add these yet, but instead wait until they've been included in a block (this will happen as part of normal block processing, no need for extra code). Inputs from pending transactions will call mark_as_spent to remove the associated outputs from _unspent_outputs. Eventually we also need to deal with cleaning out transactions coming from blocks that have been rejected (blockchain fork rollback).
Remove from outputs subcontainer whenever we mark_as_spent.

Invalidating a pending transaction:  need to handle when a pending transaction is canceled/invalidated by another transaction in a new block that spends one of the inputs to our pending transaction.
We detect this by submitting all pending transactions to blockchain.evaluate_transaction() whenever we receive a new block.

Handling an invalidated transaction:
1) we need to re-add any of the transaction inputs' outputs back to _unspent_outputs_of_address for their owning address (money wasn't spent because transaction was invalidated) (except any outputs spent by the "invalidating transaction", of which there should be at least one). TODO: How to handle the overlap of spending inputs between the transaction and the invalidating transaction?
2) we need to remove any of the transaction's outputs from _unspent_outputs_of_address for their owning address (money wasn't delivered because transaction was invalidated).

We also want to record any invalidated transactions.
We're not going to consider invalidation between pending transactions.

//address_state: this is only needed if we want to maintain running balances, but it simplifies many possible later changes if we implement it now. We may want to change the _unspent_outputs_of_address to map to these objects instead of outputs and add outputs as a member of this address state object.
struct address_state
  address
  memo
  account?
  balance?
  unconfirmed_balance?
//do we need to map from addresses to their owning account? If so, we could store it in a field of the address_state object.

The scan_output function scans pending and blockchain transactions. We always add outputs we find here
to unspent outputs, but we should only add outputs that are from confirmed transactions now.
Can such an output have already been spent (so it shouldn't be added)? It couldn't have been spent by this wallet, but maybe another wallet could have spent it if it had already processed the block as confirmed a little before we do, then issued out the spending transaction which we then receive and process before processing the original funding transaction in the block. This is an unlikely scenario, but it may be a hole we need to close in the future.

In the current code, spent_outputs is being used to determine if an output is an output we control for balance calculations. But this can be done by checking output_ref_to_index (or output_index_to_ref). Do we have any need to keep track of spent_outputs? Maybe for assertion checking? Looks like not needed, remove.

receive_addresses: these are public keys we control that may be referenced in transaction endpoints. They have no balances until a transaction specifies an output to a receive address.

output_reference type: points to an output as (transaction_hash, output_index_in_transaction)

output_index type: points to an output as (block_number,transaction_index_in_block, output_index_in_transaction)
//For efficiency reasons, the wallet maps outputs as output_indexes. This allows sorting via block number so that older unspent outputs will be found first collecting unspent outputs to spend when generating a transaction. Note that pending transactions don't have a block and can't be looked up this way, but we should never try to spend an output from a pending transaction, so this should be ok.

unspent_outputs: this container points to transaction outputs in a transaction whose amounts have been transferred to an address we control (and not yet spent). We keep one for each receiving address, and we use it both for collecting inputs for transactions we're generating and for computing confirmed and unconfirmed balances for the address, owning accounts, and the overall wallet (for each asset type).

@code

////////////////////////////////////new code

//we use these to track wallet information such as current balances for each receiving address in the wallet
struct receiving_address : public address?
  address
  memo //describes nature of this address (e.g. who sends money to it)
  map<output_index, trx_output> unspent_outputs //for computing balances and collecting inputs for transactions
  owning_account? //any use for this?
  //not going to cache balances, as it would require re-computation everytime transaction becomes confirmed
  //balance?
  //unconfirmed_balance?

struct account
  set<receiving_address> addresses //we uniquify address_state based on address public key
  //should we have an account memo also?
  get_unspent_outputs() returns union of unspent_outputs of all addresses in acount

wallet_data
  unordered_map<transaction_id_type,transaction_state> _block_transactions
  unordered_map<transaction_id_type,transaction_state> _pending_transactions
  set<account> _accounts //we uniquify accounts based on their string name

//for now we compute all balances on-demand
//OPTION 1: compute balances directly from all unspent outputs
compute_all_balances
  foreach account in _accounts
    foreach receiving_address in account
      foreach unspent_output to receiving_address.unspent_outputs
        if is_confirmed_transaction(unspent_output's transaction)
          address.confirmed_balance += unspent_output.amount
          account.confirmed_balance += unspent_output.amount
        else
          address.unconfirmed_balance += unspent_output.amount
          account.unconfirmed_balance += unspent_output.amount
//OPTION 2: compute balances from transaction history. This was the original method used, but it relies on delta balances to be precomputed during original scanning of the transactions as they are added to _block_transactions and _pending_transactions. This is slightly faster, but it wasn't designed to deal with accounts (the idea was just to generate one overall total balance). For example, addresses can be moved from one account to another, so it's not possible to keep a single delta balance for each asset. Now we need to keep track of the balance for each address receving or losing funds as a result of the transaction (this is effectively what OPTION 1 does, and it does it using the unspent_outputs data, which needs to be maintained for collecting inputs anyways).
compute_all_balances (deprecated algorithm)
  foreach transaction in _transactions
    balance += transaction.delta_balance;

bool is_confirmed_transaction(transaction_id)
  if transaction_id in _block_transactions
    return _transactions[transaction_id].block_number < current_block_number - REQUIRED_CONFIRMING_DELEGATES_COUNT
  else
    return false

    //QUESTION: Should this return unconfirmed and pending transactions? Or should that be separately
    //          accessible?
    //returns a map of all the wallet transaction states (transaction_id -> transaction_state)
get_transaction_history()
  return _data.transactions map;

//this creates a transaction that says you want to be considered as a delegate
register_delegate(name,data)
  create transaction object and set transaction output to claim_name_output with a newly generated public key for delegate

//transfer amount to an address from an account (attach a memo to transaction itself eventually?). This used to be: transfer(amount,to-address,memo)
send_to_address(to_address,amount,memo)
  create transaction object and set to-address as first transaction output (a change output may also be added by next step)
  available_funding_outputs = union of unspent_outputs from all receive addresses (we'll count genesis block funding info as receive accounts also)
  collect_inputs_and_sign(transaction,amount,available_funding_outputs,memo)

//new function
send_from_account(from_account,to_address,amount,min_confirmations?, memo,comment_to)
  create transaction object and set to-address as first transaction output (a change output may also be added by next step)
  available_funding_outputs = from_account.get_unspent_outputs()
  collect_inputs_and_sign(transaction,amount,available_funding_outputs,memo)

mark_as_spent(output_reference)
  remove output_reference from address.unspent_outputs

void sign_transaction( signed_transaction& transaction, addresses, bool mark_output_as_used = true)
  sign transaction addresses and mark_as_spent the inputs if requested

collect_inputs_and_sign(transaction,requested_amount,required_signatures, change_address, unspent_outputs)
  required_input = requested_amount
  save off original inputs and outputs to transaction
  do
    restore original inputs and outputs to transaction (this is not efficient, but I suppose we don't care right now)
    total_input = required_amount
    new_inputs = collect_inputs(required_input, total_input, required_signatures,unspent_outputs)
    add new_inputs to transaction
    change_amount = total_input - requested_input;
    add output transaction to change_address for change_amount
    if requested transaction is not in base asset type
      return collect_inputs_and_sign again //get danL to explain why this is done in more detail

    sign transaction with any required_signatures (doesn't mark inputs as spent here)
    compute fee from transaction size
    required_input += fee
    if (total_input < required_input)
      continue;
    Calculate leftover change
    change_amount = total_input - required_input
  while (total_input < required_input);
  change_amount = total_input - required_fee
  if change_amount > 0
    update change output transaction with current change amount
  else
    remove change output from transaction
  clear transactions signatures
  re-sign transaction, this time marking inputs as spent

//Collect inputs that total to at least requested_amount.
inputs collect_inputs(requested_amount, total_input, required_signatures, unspent_outputs)
  for each unspent output in unspent_outputs
    if output contains proper asset type
      create an input using this output
      total_input += output's amount
      add this output as a required signature for the transaction
      if (total_input.get_rounded_amount() > requested_amount.get_rounded_amount())
        return inputs
  throw "insufficient funds"


bool scan_input(transaction_state,output,output_reference,output_index)
  if we control the input's output source
    decrease delta balance of transaction by output amount (this input is our money being spent)
    return true (input affects wallet)
  else
    return false

//we add the output to unspent_outputs regardless of whether transaction is confirmed, but we will
//only use confirmed outputs when collecting inputs (this means we will need to check the confirmed state
//of the owning transaction, but this should be a reasonably fast operation now).
bool scan_output(transaction_state,output,output_reference,output_index)
  if we control the output (if output's address is one of our receive addresses)
    increase delta balance of transaction by output amount (this is money being sent to us)
    add output to unspent_outputs
    return true (output affects wallet)
  else
    return false

bool scan_transaction(transaction_state, block_index, transaction_index)
  foreach input in the transaction
    if output in output_ref_to_index
      scan_input(...)
      mark_as_spent(output_ref) //move from unspent to spent outputs container
  for each output in the transaction
    scan_output(...)
  return true if any input or output affects addresses we control

//scan chain is called every time we receive a new block
scan_chain(chain_database, from_block_num, scan_progress_callback)
  foreach block starting from_block_num
    foreach transaction
      check if any callback is registered for reporting progress of scanning transactions
      fetch from chain
      found_output = scan_transaction
      if found_output
        add new transaction state to map (effectively a set) of transactions affecting wallet
    foreach deterministic transaction
      fetch from chain
      found_output = scan_transaction
      if found_output
        add new transaction state to map of transactions affecting wallet
  set_fee_rate(chain.get_fee_rate())
  _stake = chain.get_stake()
  _last_scanned_block_num = head_block_num
  return if a new input was found or an output was spent

get_balance(asset_type)
  sum up the unspent_outputs for the requested asset type  //?expand on this

//generate next block from a set of pending transactions
result generate_next_block(chain_database,input_transactions)
  chain_db.generate_deterministic_transactions()
  foreach transaction in input_transactions
    validate transaction and discard if invalid (transaction validated in isolation)
    compute fee for transaction
    if transaction fee < fee_rate * transaction size
      report enough fee wasn't paid and skip transaction
    else
      add to valid_transactions
  sort transactions with highest fees first
  start with empty consumed_outputs container
  foreach transaction in valid_transactions
    foreach transaction input
      if transaction in consumed_outputs
        mark transaction to be skipped
      else
        add transaction to consumed_outputs
    if transaction has no consumed_outputs
      try to add it to block (evaluted in context of already added transactions)
  calculate and return result containing: new block number,
     a list of all accepted transactions for new block, previous block id,
     merkle root of deterministic transactions for block, fee rate for next block,
     total outstanding shares after removal of fees, and timestamp











////////////////////////////////////existing code

//returns a map of all the wallet transaction states (transaction_id -> transaction_state)
get_transaction_history()
  return _data.transactions map;

//transfer amount to an address
transfer(amount,to-address,memo)
  create transaction object and set to-address as first transaction output (a change output may also be added by next step)
  collect_inputs_and_sign(transaction,amount,memo)

//this creates a transaction that says you want to be considered as a delegate
register_delegate(name,data)
  create transaction object and set transaction output to claim_name_output with a newly generated public key for delegate

mark_as_spent(output_reference)
  if output reference is not ours (not in output_ref_to_index map) or we've already spent it
    just ignore it //consider if we can/should assert if already spent
  else
    remove from unspent_outputs and move to spent_outputs

void sign_transaction( signed_transaction& transaction, addresses, bool mark_output_as_used = true)
  sign transaction addresses and mark_as_spent the inputs if requested

collect_inputs_and_sign(transaction,requested_amount,required_signatures, change_address)
  required_input = requested_amount
  save off original inputs and outputs to transaction
  do
    restore original inputs and outputs to transaction (this is not efficient, but I suppose we don't care right now)
    total_input = required_amount
    new_inputs = collect_inputs(required_input, total_input, required_signatures)
    add new_inputs to transaction
    change_amount = total_input - requested_input;
    add output transaction to change_address for change_amount
    if requested transaction is not in base asset type
      return collect_inputs_and_sign again //explain why this is done in more detail

    sign transaction with any required_signatures (doesn't mark inputs as spent here)
    compute fee from transaction size
    required_input += fee
    if (total_input < required_input)
      continue;
    Calculate leftover change
    change_amount = total_input - required_input
  while (total_input < required_input);
  change_amount = total_input - required_fee
  if change_amount > 0
    update change output transaction with current change amount
  else
    remove change output from transaction
  clear transactions signatures
  re-sign transaction, this time marking inputs as spent

//Collect inputs that total to at least requested_amount.
inputs collect_inputs(requested_amount, total_input, required_signatures)
  for each unspent output
    if output contains proper asset type
      create an input using this output
      total_input += output's amount
      add this output as a required signature for the transaction
      if (total_input.get_rounded_amount() > requested_amount.get_rounded_amount())
        return inputs
  throw "insufficient funds"

bool scan_input(transaction_state,output,output_reference,output_index)
  if we control the input's output source(it's in our spent or unspent outputs)
    decrease delta balance of transaction by output amount (this input is our money being spent)
    return true (input affects wallet)
  else
    return false

bool scan_output(transaction_state,output,output_reference,output_index)
  if we control the output (if output's address is one of our receive addresses)
    increase delta balance of transaction by output amount (this is money being sent to us)
    add output to unspent_outputs
    return true (output affects wallet)
  else
    return false

bool scan_transaction(transaction_state, block_index, transaction_index)
  foreach input in the transaction
    if output in output_ref_to_index
      scan_input(...)
      mark_as_spent(output_ref) //move from unspent to spent outputs container
  for each output in the transaction
    scan_output(...)
  return true if any input or output affects addresses we control

scan_chain(chain_database, from_block_num, scan_progress_callback)
  foreach block starting from_block_num
    foreach transaction
      check if any callback is registered for reporting progress of scanning transactions
      fetch from chain
      found_output = scan_transaction
      if found_output
        add new transaction state to map (effectively a set) of transactions affecting wallet
    foreach deterministic transaction
      fetch from chain
      found_output = scan_transaction
      if found_output
        add new transaction state to map of transactions affecting wallet
  set_fee_rate(chain.get_fee_rate())
  _stake = chain.get_stake()
  _last_scanned_block_num = head_block_num
  return if a new input was found or an output was spent

//probably should cache the balances for each asset type instead
get_balance(asset_type)
  sum up the unspent_outputs for the requested asset type

collect_mining_input (deprecated, remove?)

//generate next block from a set of pending transactions
result generate_next_block(chain_database,input_transactions)
  chain_db.generate_deterministic_transactions()
  foreach transaction in input_transactions
    validate transaction and discard if invalid (transaction validated in isolation)
    compute fee for transaction
    if transaction fee < fee_rate * transaction size
      report enough fee wasn't paid and skip transaction
    else
      add to valid_transactions
  sort transactions with highest fees first
  foreach transaction in valid_transactions
    foreach transaction input
      if transaction in consumed_outputs
        mark transaction to be skipped
      else
        add transaction to consumed_outputs
    if transaction has no consumed_outputs
      try to add it to block (evaluted in context of already added transactions)
  calculate and return result containing: new block number,
     a list of all accepted transactions for new block, previous block id,
     merkle root of deterministic transactions for block, fee rate for next block,
     total outstanding shares after removal of fees, and timestamp

@endcode

## General Notes
- Generation of transactions (transfer) could be speeded up a lot (there's a lot of potential for re-doing old work when the fees require more inputs to the transaction), but probably we don't care right now.

## Things to do (lots to be added here)
- Function to generate unconfirmed balances from pending transactions for each asset type
- Report partial confirmation of blockchain transactions
- Randomize outputs of generated transactions
- Increase fee paid for transactions to avoid transaction not getting accepted if there are one or more "unseen blocks" on network with increased fee rates.

# Wallet command-line options (options when launching wallet)

# Wallet RPC API
Below are a list of the RPC commands supported by the wallet and the usage of each command. When defining new commands, if it is not a bitcoin-compatible command, use underscores to separate words in the command (for example, use add_send_address, not addsendaddress as this is a non-bitcoin compatible commands).

help:
lists wallet commands, or get help for a specified command.

openwallet (BTS):
unlock the wallet with the given passphrase, if no user is specified 'default' will be used.
              /* params:          name                 type      required */
                                {{"wallet_username",   "string", false} ,
                                 {"wallet_passphrase", "string", false}},


createwallet(BTS):
                /* description */ "create a wallet with the given passphrases",
                /* returns: */    "bool",
                /* params:          name                   type      required */
                                  {
                                   {"wallet_username",     "string", true},
                                   {"wallet_passphrase",   "string", true},
                                   {"spending_passphrase", "string", true}
                                  },


currentwallet(BTS):
                 /* description */ "returns the username passed to openwallet",
                 /* returns: */    "string",
                 /* params:     */ {},

closewallet(BTS):
               /* description */ "closes the curent wallet, if one is open.",
               /* returns: */    "bool",
               /* params:     */ {},

walletpassphrase:
                    /* description */ "unlock the private keys in the wallet with the given passphrase",
                    /* returns: */    "bool",
                    /* params:          name                   type      required */
                                      {{"spending_passphrase", "string", true},
                                       {"timeout",             "int",    true} },
                  /* prerequisites */ json_authenticated | wallet_open};
"""
walletpassphrase "passphrase" timeout

Stores the wallet decryption key in memory for 'timeout' seconds.
This is needed prior to performing transactions related to private keys such as sending bitcoins

Arguments:
1. "passphrase" (string, required) The wallet passphrase
2. timeout (numeric, required) The time to keep the decryption key in seconds.

Note:
Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock
time that overrides the old one if the new time is longer than the old one, but you can imediately
lock the wallet with the walletlock command.

Examples:

unlock the wallet for 60 seconds
> bitshares-cli walletpassphrase "my pass phrase" 60

Lock the wallet again (before 60 seconds)
> bitshares-cli walletlock

As json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "walletpassphrase", "params": ["my pass phrase", 60] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

getnewaddress:
                 /* description */ "create a new address for receiving payments",
                 /* returns: */    "address",
                 /* params:          name       type      required */
                                   {{"account", "string", false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};
"""
getnewaddress ( "account" )

Returns a new BitShares address for receiving payments.
If 'account' is specified (recommended), it is added to the address book
so payments received with the address will be credited to 'account'.

Arguments:
1. "account" (string, optional) The account name for the address to be linked to. if not provided, the default account "" is used. It can also be set to the empty string "" to represent the default account. The account does not need to exist, it will be created if there is no account by the given name.

Result:
"bitsharesaddress" (string) The new BitShares address

Examples:
> bitshares-cli getnewaddress
> bitshares-cli getnewaddress ""
> bitshares-cli getnewaddress "myaccount"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getnewaddress", "params": ["myaccount"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""



add_send_address (BTS):
                    /* description */ "add new address for sending payments",
                    /* returns: */    "bool",
                    /* params:          name       type       required */
                                      {{"address", "address", true},
                                       {"label",   "string",  true}  },
                  /* prerequisites */ json_authenticated | wallet_open };


sendtoaddress:
                 /* description */ "Sends the given amount to the given address, assumes shares in DAC",
                 /* returns: */    "transaction_id",
                 /* params:          name          type       required */
                                   {{"to_address", "address", true},
                                    {"amount",     "uint64",   true},
                                    {"comment",    "string",  false},
                                    {"to_comment", "string",  false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked | connected_to_network};
"""
sendtoaddress "bitsharesaddress" amount ( "comment" "comment-to" )

Sent an amount to a given address. The amount is a 64bit integer.

Arguments:
1. "bitsharesaddress" (string, required) The bitcoin address to send to.
2. "amount" (numeric, required) The amount in BTS to send. eg 10
3. "comment" (string, optional) A comment used to store what the transaction is for.
This is not part of the transaction, just kept in your wallet.
4. "comment-to" (string, optional) A comment to store the name of the person or organization
to which you're sending the transaction. This is not part of the
transaction, just kept in your wallet (TODO: ignored currently, implement later).

Result:
"transactionid" (string) The transaction id. (view at https://????/tx/[transactionid])

Examples:
> bitshares-cli sendtoaddress "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 10
> bitshares-cli sendtoaddress "1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd" 10 "donation" "seans outpost"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "sendtoaddress", "params": ["1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd", 10, "donation", "seans outpost"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""
//TODO: determine if we should ignore quotes in interactive cli around address.

list_receive_addresses(BTS):
                     /* description */ "Lists all receive addresses and their labels associated with this wallet",
                     /* returns: */    "map<address,string>",
                     /* params:     */ {},
                   /* prerequisites */ json_authenticated | wallet_open};

list_send_addresses(BTS):
                     /* description */ "Lists all foregin addresses and their labels associated with this wallet",
                     /* returns: */    "map<address,string>",
                     /* params:     */ {},
                   /* prerequisites */ json_authenticated | wallet_open};

get_send_address_label(BTS):
                          /* description */ "Looks up the label for a single send address, returns null if not found",
                          /* returns: */    "string",
                         /* params:            name          type       required */
                                            { {"address",    "address", true} },
                        /* prerequisites */ json_authenticated | wallet_open};

getbalance:
              /* description */ "Returns the wallet's current balance",
              /* returns: */    "asset",
              /* params:          name     type     required */
                                {{"asset", "unit",  false}},
            /* prerequisites */ json_authenticated | wallet_open};
"""
getbalance ( "account" minimum_confirmations )

If account is not specified, returns the wallet's total available balance.
If account is specified, returns the balance in the account.
Note that the account "" is not the same as leaving the parameter out.
The wallet total may be different to the balance in the default "" account.

Arguments:
1. "account" (string, optional) The selected account, or "*" for entire wallet. It may be the default account using "".
2. minimum_confirmations (numeric, optional, default=1) Only include transactions confirmed at least this many times.

Result:
amount (numeric) The total amount in BTS received for this account.

Examples:

The total amount in the server across all accounts
> bitshares-cli getbalance

The total amount in the server across all accounts, with at least 5 confirmations
> bitshares-cli getbalance "*" 6

The total amount in the default account with at least 1 confirmation
> bitshares-cli getbalance ""

The total amount in the account named tabby with at least 6 confirmations
> bitshares-cli getbalance "tabby" 6

As a json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getbalance", "params": ["tabby", 6] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""


get_transaction_history(BTS):
                           /* description */ "Retrieves all transactions into or out of this wallet.",
                           /* returns: */    "map<transaction_id,transaction_state>",
                           /* params:     */ {},
                         /* prerequisites */ json_authenticated};


get_transaction (BTC compatible, change to gettransaction):
                   /* description */ "Retrieves the signed transaction matching the given transaction id",
                   /* returns: */    "signed_transaction",
                   /* params:          name              type               required */
                                     {{"transaction_id", "transaction_id",  true}},
                 /* prerequisites */ json_authenticated};
"""
gettransaction "txid"

Get detailed information about in-wallet transaction <txid>

Arguments:
1. "txid" (string, required) The transaction id

Result:
{
"amount" : xx, (numeric) The transaction amount in BTS
"confirmations" : n, (numeric) The number of confirmations
"blockhash" : "hash", (string) The block hash
"blockindex" : xx, (numeric) The block index
"blocktime" : ttt, (numeric) The time in seconds since epoch (1 Jan 1970 GMT)
"txid" : "transactionid", (string) The transaction id, see also https://???.info/tx/[transactionid]
"time" : ttt, (numeric) The transaction time in seconds since epoch (1 Jan 1970 GMT)
"timereceived" : ttt, (numeric) The time received in seconds since epoch (1 Jan 1970 GMT)
"details" : [
{
"account" : "accountname", (string) The account name involved in the transaction, can be "" for the default account.
"address" : "bitsharesaddress", (string) The BitShares address involved in the transaction
"category" : "send|receive", (string) The category, either 'send' or 'receive'
"amount" : xx (numeric) The amount in BTS
}
,...
],
"hex" : "data" (string) Raw data for transaction
}

bExamples
> bitshares-cli gettransaction "1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "gettransaction", "params": ["1075db55d416d3ca199f55b6084e2115b9345e16c5cf302fc80e9d5fbf5d48d"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

getblock:
            /* description */ "Retrieves the block header for the given block",
            /* returns: */    "block_header",
            /* params:          name              type        required */
                              {{"block_number",   "uint32_t", true}},
          /* prerequisites */ json_authenticated};
"""
getblock "hash" ( verbose )

If verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.
If verbose is true, returns an Object with information about block <hash>.

Arguments:
1. "hash" (string, required) The block hash
2. verbose (boolean, optional, default=true) true for a json object, false for the hex encoded data

Result (for verbose = true):
{
"hash" : "hash", (string) the block hash (same as provided)
"confirmations" : n, (numeric) The number of confirmations
"size" : n, (numeric) The block size
"height" : n, (numeric) The block height or index
"version" : n, (numeric) The block version
"merkleroot" : "xxxx", (string) The merkle root
"tx" : [ (array of string) The transaction ids
"transactionid" (string) The transaction id
,...
],
"time" : ttt, (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)
"nonce" : n, (numeric) The nonce //TODO: fake this
"bits" : "1d00ffff", (string) The bits
"difficulty" : x.xxx, (numeric) The difficulty //TODO: fake this
"previousblockhash" : "hash", (string) The hash of the previous block
"nextblockhash" : "hash" (string) The hash of the next block
}

Result (for verbose=false):
"data" (string) A string that is serialized, hex-encoded data for block 'hash'.

Examples:
> bitshares-cli getblock "00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getblock", "params": ["00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

validateaddress:
                   /* description */ "Checks that the given address is valid",
                   /* returns: */    "bool",
                   /* params:          name              type       required */
                                     {{"address",        "address", true}},
                 /* prerequisites */ json_authenticated};
"""
validateaddress "bitsharesaddress"

Return information about the given BitShares address.

Arguments:
1. "bitsharesaddress" (string, required) The BitShares address to validate

Result:
{
"isvalid" : true|false, (boolean) If the address is valid or not. If not, this is the only property returned.
"address" : "bitsharesaddress", (string) The BitShares address validated
"ismine" : true|false, (boolean) If the address is yours or not
"isscript" : true|false, (boolean) If the key is a script
"pubkey" : "publickeyhex", (string) The hex value of the raw public key
"iscompressed" : true|false, (boolean) If the address is compressed
"account" : "account" (string) The account associated with the address, "" is the default account
}

Examples:
> bitshares-cli validateaddress "1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "validateaddress", "params": ["1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

rescan(BTS):
          /* description */ "Rescan the block chain from the given block",
          /* returns: */    "bool",
          /* params:          name              type    required */
                            {{"starting_block", "bool", false}},
        /* prerequisites */ json_authenticated | wallet_open};

import_bitcoin_wallet(BTS):
                         /* description */ "Import a bitcoin wallet",
                         /* returns: */    "bool",
                         /* params:          name               type       required */
                                           {{"wallet_filename", "string",  true},
                                            {"wallet_password", "string",  true}},
                       /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

importprivkey:
                 /* description */ "imports a bitcoin private key from wallet import format WIF",
                 /* returns: */    "bool",
                 /* params:          name           type            required */
                                   {{"key",         "private_key",  true},
                                    {"label",       "string",       true},
                                    {"rescan",      "bool",         false}},
               /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};
"""
importprivkey "bitcoinprivkey" ( "account" rescan "address_label")

Adds a private key (as returned by dumpprivkey) to your wallet.

Arguments:
1. "bitcoinprivkey" (string, required) The private key (see dumpprivkey)
2. "account" (string, optional) the name of the account to put this key in
3. rescan (boolean, optional, default=true) Rescan the wallet for transactions
4. "address_label" (string,optional) assigns a label to the address being imported

Examples:

Dump a private key from Bitcoin wallet
> bitcoin-cli dumpprivkey "myaddress"

Import the private key to BitShares wallet
> bitshares-cli importprivkey "mykey"

Import using an account name
> bitshares-cli importprivkey "mykey" "testing" false "address_label"

As a json rpc call
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "importprivkey", "params": ["mykey", "testing", false] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

import_private_key(BTS):
                      /* description */ "imports a bitshares private key from hex format",
                      /* returns: */    "bool",
                      /* params:          name           type            required */
                                        {{"key",         "private_key",  true},
                                         {"label",       "string",       true}},
                    /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

_send_transaction(BTS)
                   /* description */ "Broadcast a previously-created signed transaction to the network",
                   /* returns: */    "transaction_id",
                   /* params:          name                  type                   required */
                                     {{"signed_transaction", "signed_transaction",  true}},
                 /* prerequisites */ json_authenticated | connected_to_network};

_create_sendtoaddress_transaction(BTS, only temporary command, will be replaced soon):
                                     /* description */ "Creates a transaction in the same manner as 'sendtoaddress', but do not broadcast it",
                                     /* returns: */    "signed_transaction",
                                     /* params:          name          type       required */
                                                       {{"to_address", "address", true},
                                                        {"amount",     "asset",   true},
                                                        {"comment",    "string",  false},
                                                        {"to_comment", "string",  false}},
                                   /* prerequisites */ json_authenticated | wallet_open | wallet_unlocked};

getconnectioncount:
                      /* description */ "returns the current number of active peer connections",
                      /* returns: */    "bool",
                      /* params:     */ {},
                    /* prerequisites */ json_authenticated};
"""
getconnectioncount

Returns the number of connections to other nodes.

bResult:
n (numeric) The connection count

Examples:
> bitshares-cli getconnectioncount
> curl --user myusername --data-binary '{"jsonrpc": "1.0", "id":"curltest", "method": "getconnectioncount", "params": [] }' -H 'content-type: text/plain;' http://127.0.0.1:8332/
"""

##


*/
